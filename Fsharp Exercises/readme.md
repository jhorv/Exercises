6/18/2016:

Let me initialize this repo here. Unlike Haskell, I am already quite proficient at F#, so I won't be doing things like HackerRank exercises. I think in the end with regards to Haskell, I would say that I am quite comfortable with programming in it in a purely functional manner. Hopefully that should be enough for the Futhark compiler. I do not think I would be comfortable doing work in anything more than that.

Lately, having learned Haskell, I have come to feel like learning about [OCaml](https://www.fun-mooc.fr/courses/parisdiderot/56002/session01/Table_of_Contents/) while reading the tome by Diehl in tandem.

After that I'll look into creating GUIs in F#, though I've read that C# might be better for that.

UPDATE: Done with Haskell. In the end, I think it is just a meaningless morass of abstraction. Maybe I am too stupid to understand its deep insights, but I think out of roughly 30 days that I spent learning it, I could have left about 20 out. Insofar I've become a better programmer, that is because I programmed in a purely functional way in a while, not because of all that pointless type theory stuff.

The deeper the abstraction is, the more it needs to be beholden to reality - I think the science types are too eager to forget this sometimes. At that point, science becomes merely superstition.

I do not think learning Haskell past this point will make me a better programmer. The one interesting technique, the lambda-stacking fold is not something I can use in eager languages anyway.

Human-made programming languages might have reached [their pinnacle](https://blogs.janestreet.com/the-ml-sweet-spot/) with SML from which F# and OCaml derive. They aren't obsolete anymore than plain arrays and the plus operator is.

I need a break even though it is only 9:15am here.

I think I'll watch the OCaml videos for a bit. I think that might cheer me up. I feel a need to go on a firmer footing.

UPDATE: It seems the course is closed and so are the lectures, so I found these [lecture notes](http://www.ii.uni.wroc.pl/~lukstafi/pmwiki/index.php?n=Functional.Functional) for a different course for a different functional programming course in OCaml to tide me over.

My God, the early lectures are damn brutal. I already know this stuff, so it is not a problem to me, but the instructor does not hold back even a little.

At any rate, I like this. Impure, eager language like OCaml is definitely my cup of tea. My great greed drives to me to take all that I can, but not all can be compressed into a single point. A single great thrust is all that is needed to break the morass of abstraction. I'll be content to let Haskellers play in their own corner of the playground.

It is not my fault, but I really regret how the story SML played out. The greatest language of all time, so great that it has well over a dozen compilers and the eggheads doing them could not get together to form a community around a dominant implementation like with GHC. This probably set back the programming community by at least a decade.

Functional programming courses like the one above do not help much either.

Is it really necessary to start off with massive recursion, symbolic differentiation and continuation passing style in like the first three lectures? **(Edit: Actually, I'll forgive this one since it is obviously not a beginner's class.)**

The greatest thing about the (ML style) functional languages are their type safety and lightweight type inference - the rest is really not that important in comparison. It allows one to use the far stronger hybrid functional/imperative style than would be possible if one programmed in say C++ or Python.

This is pretty much why I gave up on Python after day one. There is no point in programming in a language where I could not be at my best. Scala and Haskell fall into that inconvenient category.

I feel a bit lonely because of this. Two great languages is not much to go on, but it should make do. One is enough in fact.

UPDATE: Actually, this stuff in [lecture 5](http://www.ii.uni.wroc.pl/~lukstafi/pmwiki/uploads/Functional/functional-lecture05.pdf) is quite interesting. Would this alternating type list even be possible in F#? And these function signatures...I never even thought of doing type annotations like this. It is quite interesting.

UPDATE: This stuff on modules in genuinely novel to me. And as matter of fact, tree based structures are exactly the area of my current (temporary) interest.

This is good stuff. I wonder if I could replace the OCaml modules with .NET abstract classes, or are there some limitation to this?

Also going through these notes make me wonder whether there was anything in the Expert F# book on this.

UPDATE: Done with lecture 5. I think as an exercise, I am going to be transcribing everything step by step into F# when I am done going through all the notes. Tree based data structures were one thing I was content to leave to libraries, so when the Scala assignment came out, it hit me right where it hurts. I'll plug this hole in my skillset at all cost.

UPDATE: I see that lecture 6 has some stuff on constraint propagation. Damn, I wish I there were videos along with the lectures.

Actually, the difficulty of course is not the problem. A difficulty of a course is not the problem.

The real problem is generally false advertising, which is not the case here though as nowhere does it state that the assignment that would take 5d in reality should take 3h on paper.

There is definitely a lot of good information here.

UPDATE: A third of the day left to go. These lecture notes are too much to go all through in just one day. And I did a lot besides this as well.

It is difficult to explain how natural the OCaml code seems to me. Despite not having written a line of the language before, it crystal clear to me, unlike the Haskell code. This will do it. OCaml will heal my soul. I know what I stand on here; I am not amongst the clouds.

UPDATE: The course even has stuff on constraint propagation. It uses lists though which is bleh.
