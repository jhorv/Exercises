6/18/2016:

Let me initialize this repo here. Unlike Haskell, I am already quite proficient at F#, so I won't be doing things like HackerRank exercises. I think in the end with regards to Haskell, I would say that I am quite comfortable with programming in it in a purely functional manner. Hopefully that should be enough for the Futhark compiler. I do not think I would be comfortable doing work in anything more than that.

Lately, having learned Haskell, I have come to feel like learning about [OCaml](https://www.fun-mooc.fr/courses/parisdiderot/56002/session01/Table_of_Contents/) while reading the tome by Diehl in tandem.

After that I'll look into creating GUIs in F#, though I've read that C# might be better for that.

UPDATE: Done with Haskell. In the end, I think it is just a meaningless morass of abstraction. Maybe I am too stupid to understand its deep insights, but I think out of roughly 30 days that I spent learning it, I could have left about 20 out. Insofar I've become a better programmer, that is because I programmed in a purely functional way in a while, not because of all that pointless type theory stuff.

The deeper the abstraction is, the more it needs to be beholden to reality - I think the science types are too eager to forget this sometimes. At that point, science becomes merely superstition.

I do not think learning Haskell past this point will make me a better programmer. The one interesting technique, the lambda-stacking fold is not something I can use in eager languages anyway.

Human-made programming languages might have reached [their pinnacle](https://blogs.janestreet.com/the-ml-sweet-spot/) with SML from which F# and OCaml derive. They aren't obsolete anymore than plain arrays and the plus operator is.

I need a break even though it is only 9:15am here.

I think I'll watch the OCaml videos for a bit. I think that might cheer me up. I feel a need to go on a firmer footing.

UPDATE: It seems the course is closed and so are the lectures, so I found these [lecture notes](for a different course) for a different functional programming course in OCaml to tide me over.

My God, the early lectures are damn brutal. I already know this stuff, so it is not a problem to me, but the instructor does not hold back even a little.

At any rate, I like this. Impure, eager language like OCaml is definitely my cup of tea. My great greed drives to me to take all that I can, but not all can be compressed into a single point. A single great thrust is all that is needed to break the morass of abstraction. I'll be content to let Haskellers play in their own corner of the playground.

It is not my fault, but I really regret how the story SML played out. The greatest language of all time, so great that it has well over a dozen compilers and the eggheads doing them could not get together to form a community around a dominant implementation like with GHC. This probably set back the programming community by at least a decade.

Functional programming courses like the one above do not help much either.

Is it really necessary to start off with massive recursion, symbolic differentiation and continuation passing style in like the first three lectures?

The greatest thing about the (ML style) functional languages are their type safety and lightweight type inference - the rest is really not that important in comparison. It allows one to use the far stronger hybrid functional/imperative style than would be possible if one programmed in say C++ or Python.

This is pretty much why I gave up on Python after day one. There is no point in programming in a language where I could not be at my best. Scala and Haskell fall into that inconvenient category.

I feel a bit lonely because of this. Two languages is not much to go on, but I should make do.
